<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Tetris Matem√°tico - 7¬∫ Ano (Potencia√ß√£o e Radicia√ß√£o)</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: #0f172a;
      color: #e2e8f0;
      font-family: 'Segoe UI', sans-serif;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 6px;
      overflow: hidden;
    }

    h1 {
      font-size: 1.3rem;
      text-align: center;
      margin: 6px 0 8px;
      line-height: 1.2;
    }

    #info {
      display: flex;
      justify-content: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .info-box {
      background: #1e293b;
      padding: 5px 8px;
      border-radius: 5px;
      font-size: 0.9rem;
      min-width: 75px;
      text-align: center;
    }

    #board {
      border: 2px solid #475569;
      background: #000;
      width: 180px;
      height: 360px;
      margin: 6px 0;
    }

    #next-piece {
      width: 140px;
      height: 70px;
      background: #000;
      border: 2px solid #475569;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 0.8rem;
      padding: 4px;
      margin-bottom: 10px;
    }

    #mobile-controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 9px;
      width: 190px;
      margin-top: 8px;
    }

    .control-btn {
      width: 50px;
      height: 50px;
      background: #334155;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 3px 5px rgba(0,0,0,0.4);
    }

    .control-btn:active {
      background: #475569;
      transform: scale(0.94);
    }

    .left { grid-column: 1; grid-row: 2; }
    .right { grid-column: 3; grid-row: 2; }
    .rotate { grid-column: 2; grid-row: 1; }
    .down { grid-column: 2; grid-row: 2; }

    #game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(15, 23, 42, 0.95);
      padding: 16px;
      border-radius: 10px;
      text-align: center;
      display: none;
      z-index: 10;
      border: 2px solid #334155;
      width: 85%;
      max-width: 260px;
    }

    button.restart-btn {
      background: #334155;
      color: white;
      border: none;
      padding: 8px 16px;
      margin-top: 10px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 6px;
      font-size: 15px;
    }
  </style>
</head>
<body>
  <h1>üßÆ TETRIS 7¬∫ ANO</h1>
  
  <div id="info">
    <div class="info-box" id="score">Pontos: 0</div>
    <div class="info-box" id="level">N√≠vel: 1</div>
    <div class="info-box" id="lines">Linhas: 0</div>
  </div>

  <div id="next-piece">
    <div>Pr√≥xima:</div>
    <canvas id="next-canvas" width="70" height="20"></canvas>
    <div id="next-equation">2¬≤ = ?</div>
  </div>

  <canvas id="board" width="180" height="360"></canvas>

  <div id="mobile-controls">
    <button class="control-btn rotate" id="btn-rotate">üîÑ</button>
    <button class="control-btn left" id="btn-left">‚óÄÔ∏è</button>
    <button class="control-btn down" id="btn-down">‚¨áÔ∏è</button>
    <button class="control-btn right" id="btn-right">‚ñ∂Ô∏è</button>
  </div>

  <div id="game-over">
    <h2>üéÆ FIM DE JOGO</h2>
    <p id="final-score">Pontos: 0</p>
    <button class="restart-btn" onclick="startGame()">Jogar Novamente</button>
  </div>

  <script>
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 18; // Menor para caber em celular

    // ‚úÖ Express√µes de potencia√ß√£o e radicia√ß√£o para 7¬∫ ano
    const EXPRESS√ïES = [
      // Potencia√ß√£o
      { expr: "2¬≤", sol: 4 },
      { expr: "3¬≤", sol: 9 },
      { expr: "4¬≤", sol: 16 },
      { expr: "5¬≤", sol: 25 },
      { expr: "2¬≥", sol: 8 },
      { expr: "3¬≥", sol: 27 },
      { expr: "1¬≤", sol: 1 },
      { expr: "0¬≤", sol: 0 },
      { expr: "10¬≤", sol: 100 },
      { expr: "2‚Å¥", sol: 16 },

      // Radicia√ß√£o
      { expr: "‚àö4", sol: 2 },
      { expr: "‚àö9", sol: 3 },
      { expr: "‚àö16", sol: 4 },
      { expr: "‚àö25", sol: 5 },
      { expr: "‚àö36", sol: 6 },
      { expr: "‚àö49", sol: 7 },
      { expr: "‚àö64", sol: 8 },
      { expr: "‚àö81", sol: 9 },
      { expr: "‚àö100", sol: 10 },
      { expr: "‚àö1", sol: 1 },
      { expr: "‚àö0", sol: 0 },
    ];

    const COLORS = [
      null,
      '#FF0D72', // I
      '#0DC2FF', // J
      '#0DFF72', // L
      '#F538FF', // O
      '#FF8E0D', // S
      '#FFE138', // T
      '#3877FF', // Z
    ];

    const PIECES = {
      I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      J: [[1,0,0],[1,1,1],[0,0,0]],
      L: [[0,0,1],[1,1,1],[0,0,0]],
      O: [[1,1],[1,1]],
      S: [[0,1,1],[1,1,0],[0,0,0]],
      T: [[0,1,0],[1,1,1],[0,0,0]],
      Z: [[1,1,0],[0,1,1],[0,0,0]]
    };

    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next-canvas');

    let board = Array.from({ length: ROWS }, () => 
      Array.from({ length: COLS }, () => ({ value: 0, sol: null, pieceId: null }))
    );
    let score = 0;
    let lines = 0;
    let level = 1;
    let gameOver = false;
    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
    let pieceIdCounter = 0;

    let player = {
      pos: { x: 0, y: 0 },
      matrix: null,
      piece: null,
      nextPiece: null,
      currentExpression: null,
      nextExpression: null,
      currentPieceId: null
    };

    function createBoard() {
      return Array.from({ length: ROWS }, () => 
        Array.from({ length: COLS }, () => ({ value: 0, sol: null, pieceId: null }))
      );
    }

    function getRandomExpressao() {
      return EXPRESS√ïES[Math.floor(Math.random() * EXPRESS√ïES.length)];
    }

    function resetPlayer() {
      const pieceTypes = Object.keys(PIECES);
      if (!player.nextPiece) {
        player.nextPiece = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
        player.nextExpression = getRandomExpressao();
      }

      player.piece = player.nextPiece;
      player.currentExpression = player.nextExpression;
      player.nextPiece = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
      player.nextExpression = getRandomExpressao();
      player.currentPieceId = ++pieceIdCounter;
      player.matrix = PIECES[player.piece].map(row => [...row]);
      player.pos.y = 0;
      player.pos.x = Math.floor(COLS / 2) - Math.floor(player.matrix[0].length / 2);

      drawNextPiece();

      if (checkCollision()) {
        gameOver = true;
        document.getElementById('final-score').textContent = `Pontos: ${score}`;
        document.getElementById('game-over').style.display = 'block';
      }
    }

    function drawMatrix(matrix, offset, color = null, alpha = 1, sol = null) {
      for (let y = 0; y < matrix.length; y++) {
        for (let x = 0; x < matrix[y].length; x++) {
          if (matrix[y][x] !== 0) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color || COLORS[Object.keys(PIECES).indexOf(player.piece) + 1];
            ctx.fillRect(
              (offset.x + x) * BLOCK_SIZE,
              (offset.y + y) * BLOCK_SIZE,
              BLOCK_SIZE,
              BLOCK_SIZE
            );
            ctx.strokeStyle = '#000';
            ctx.strokeRect(
              (offset.x + x) * BLOCK_SIZE,
              (offset.y + y) * BLOCK_SIZE,
              BLOCK_SIZE,
              BLOCK_SIZE
            );

            if (alpha === 1 && sol !== null) {
              ctx.fillStyle = '#fff';
              ctx.font = 'bold 9px Arial';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                `${sol}`,
                (offset.x + x + 0.5) * BLOCK_SIZE,
                (offset.y + y + 0.5) * BLOCK_SIZE
              );
            }
            ctx.restore();
          }
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const cell = board[y][x];
          if (cell.value !== 0) {
            ctx.fillStyle = COLORS[cell.value];
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#000';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${cell.sol}`, x * BLOCK_SIZE + 9, y * BLOCK_SIZE + 9);
          }
        }
      }

      const ghostY = (function() {
        let y = player.pos.y;
        while (y < ROWS && !checkCollisionAt(player.pos.x, y + 1)) y++;
        return y;
      })();
      drawMatrix(player.matrix, { x: player.pos.x, y: ghostY }, null, 0.2);
      drawMatrix(player.matrix, player.pos, null, 1, player.currentExpression.sol);
    }

    function checkCollisionAt(x, y, matrix = player.matrix) {
      for (let r = 0; r < matrix.length; r++) {
        for (let c = 0; c < matrix[r].length; c++) {
          if (matrix[r][c] !== 0) {
            const boardX = x + c;
            const boardY = y + r;
            if (
              boardX < 0 ||
              boardX >= COLS ||
              boardY >= ROWS ||
              (boardY >= 0 && board[boardY][boardX].value !== 0)
            ) {
              return true;
            }
          }
        }
      }
      return false;
    }

    function checkCollision() {
      return checkCollisionAt(player.pos.x, player.pos.y);
    }

    function drawNextPiece() {
      const nextCtx = nextCanvas.getContext('2d');
      nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
      const matrix = PIECES[player.nextPiece];
      const blockSize = 9;
      const offsetX = (nextCanvas.width - matrix[0].length * blockSize) / 2;
      const offsetY = (nextCanvas.height - matrix.length * blockSize) / 2;

      for (let y = 0; y < matrix.length; y++) {
        for (let x = 0; x < matrix[y].length; x++) {
          if (matrix[y][x]) {
            const colorIndex = Object.keys(PIECES).indexOf(player.nextPiece) + 1;
            nextCtx.fillStyle = COLORS[colorIndex];
            nextCtx.fillRect(offsetX + x * blockSize, offsetY + y * blockSize, blockSize, blockSize);
            nextCtx.strokeRect(offsetX + x * blockSize, offsetY + y * blockSize, blockSize, blockSize);
          }
        }
      }

      document.getElementById('next-equation').textContent = `${player.nextExpression.expr} = ?`;
    }

    function merge() {
      const colorIndex = Object.keys(PIECES).indexOf(player.piece) + 1;
      for (let y = 0; y < player.matrix.length; y++) {
        for (let x = 0; x < player.matrix[y].length; x++) {
          if (player.matrix[y][x] !== 0) {
            const boardY = player.pos.y + y;
            const boardX = player.pos.x + x;
            if (boardY >= 0) {
              board[boardY][boardX] = {
                value: colorIndex,
                sol: player.currentExpression.sol,
                pieceId: player.currentPieceId
              };
            }
          }
        }
      }
    }

    function rotate(matrix) {
      const N = matrix.length;
      const result = Array.from({ length: N }, () => Array(N).fill(0));
      for (let y = 0; y < N; y++) {
        for (let x = 0; x < matrix[y].length; x++) {
          result[x][N - 1 - y] = matrix[y][x];
        }
      }
      return result;
    }

    function playerRotate() {
      const original = player.matrix.map(row => [...row]);
      const rotated = rotate(original);
      player.matrix = rotated;

      const kicks = [0, -1, 1, -2, 2];
      let valid = false;
      for (const dx of kicks) {
        if (!checkCollisionAt(player.pos.x + dx, player.pos.y)) {
          player.pos.x += dx;
          valid = true;
          break;
        }
      }

      if (!valid) {
        player.matrix = original;
      }
    }

    function playerMove(dir) {
      if (!checkCollisionAt(player.pos.x + dir, player.pos.y)) {
        player.pos.x += dir;
      }
    }

    function playerDrop() {
      if (!checkCollisionAt(player.pos.x, player.pos.y + 1)) {
        player.pos.y++;
      } else {
        merge();
        checkAndRemoveTouching();
        clearLines();
        resetPlayer();
        updateScore();
      }
      dropCounter = 0;
    }

    function checkAndRemoveTouching() {
      const currentPiecePositions = [];
      for (let y = 0; y < player.matrix.length; y++) {
        for (let x = 0; x < player.matrix[y].length; x++) {
          if (player.matrix[y][x] !== 0) {
            const boardY = player.pos.y + y;
            const boardX = player.pos.x + x;
            if (boardY >= 0) {
              currentPiecePositions.push({ y: boardY, x: boardX });
            }
          }
        }
      }

      const sol = player.currentExpression.sol;
      let shouldRemove = false;
      let otherPiecePositions = [];

      for (const { y, x } of currentPiecePositions) {
        const directions = [[-1,0],[1,0],[0,-1],[0,1]];
        for (const [dy, dx] of directions) {
          const ny = y + dy;
          const nx = x + dx;
          if (
            ny >= 0 && ny < ROWS &&
            nx >= 0 && nx < COLS &&
            board[ny][nx].value !== 0 &&
            board[ny][nx].sol === sol &&
            board[ny][nx].pieceId !== player.currentPieceId
          ) {
            shouldRemove = true;
            const targetId = board[ny][nx].pieceId;
            for (let y2 = 0; y2 < ROWS; y2++) {
              for (let x2 = 0; x2 < COLS; x2++) {
                if (board[y2][x2].pieceId === targetId) {
                  otherPiecePositions.push({ y: y2, x: x2 });
                }
              }
            }
            break;
          }
        }
        if (shouldRemove) break;
      }

      if (shouldRemove) {
        for (const { y, x } of currentPiecePositions) {
          board[y][x] = { value: 0, sol: null, pieceId: null };
        }

        for (const { y, x } of otherPiecePositions) {
          board[y][x] = { value: 0, sol: null, pieceId: null };
        }

        const totalRemoved = currentPiecePositions.length + otherPiecePositions.length;
        score += totalRemoved * 100;
      }
    }

    function clearLines() {
      let linesCleared = 0;
      for (let y = ROWS - 1; y >= 0; y--) {
        if (board[y].every(cell => cell.value !== 0)) {
          board.splice(y, 1);
          board.unshift(Array.from({ length: COLS }, () => ({ value: 0, sol: null, pieceId: null })));
          linesCleared++;
          y++;
        }
      }

      if (linesCleared > 0) {
        lines += linesCleared;
        level = Math.floor(lines / 5) + 1;
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
        const points = [0, 40, 100, 300, 1200];
        score += points[linesCleared] * level;
      }
    }

    function updateScore() {
      document.getElementById('score').textContent = `Pontos: ${score}`;
      document.getElementById('level').textContent = `N√≠vel: ${level}`;
      document.getElementById('lines').textContent = `Linhas: ${lines}`;
    }

    function update(time = 0) {
      if (gameOver) return;
      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) {
        playerDrop();
      }
      draw();
      requestAnimationFrame(update);
    }

    function startGame() {
      document.getElementById('game-over').style.display = 'none';
      board = createBoard();
      score = 0;
      lines = 0;
      level = 1;
      dropInterval = 1000;
      gameOver = false;
      pieceIdCounter = 0;
      player.nextPiece = null;
      resetPlayer();
      updateScore();
      update();
    }

    document.getElementById('btn-left').addEventListener('click', () => playerMove(-1));
    document.getElementById('btn-right').addEventListener('click', () => playerMove(1));
    document.getElementById('btn-down').addEventListener('click', () => playerDrop());
    document.getElementById('btn-rotate').addEventListener('click', () => playerRotate());

    document.addEventListener('keydown', e => {
      if (gameOver) return;
      switch (e.keyCode) {
        case 37: playerMove(-1); break;
        case 39: playerMove(1); break;
        case 40: playerDrop(); break;
        case 38: playerRotate(); break;
      }
    });

    startGame();
  </script>
</body>
</html>